基于《深入浅出 nodeJS》，可能与现在 node 实现有所不同，粗读。

# 第一章 简介

## Node的特点

* 异步 I/O + 回调
* 单线程
  * 问题：
    * 无法利用多核
    * 错误引起整个程序退出
    * 大量计算占用 CPU 无法继续调用异步 I/O
  * 解决：
    * 创建新的线程
    * 浏览器端 web worker 解决
    * node 端 child_process 解决

# 第二章 模块机制

## CommonJS 规范

`module.exports / exports`，`require`

## Node 模块实现

* 优先从换从加载，缓存的是编译和执行之后的对象
* 路径分析和文件定位
  * 模块标识符分析
    * 核心模块
    * 路径
    * 非路径文件模块（node_modules查找等）
  * 文件定位
    * 文件名分析，如后缀补全
    * 目录分析和包，
  * 模块编译
    * 类型
      * .js 文件：通过 fs 模块同步读取并编译执行
      * .node 文件：C/C++ 编写
      * .json 文件：fs 读取，JSON.parse()
      * .其他扩展名文件：当做 .js 文件
    * 具体过程
      * .js 文件：读取后对文件进行头尾包装，封装进函数，此时会提供 exports、require 等模块化语法的声明（实现）
      * .c/c++ 模块：通过 libuv 兼容层做不同平台的兼容
      * .json 文件：fs 读取，JSON.parse()

## 核心模块

* JavaScript 核心模块编译：
  * 将内置 JavaScript 代码转换成 C++ 内数组，生成 node_natives.h 头文件，这个过程中 JavaScript 代码以字符串形式存储在 node 命名空间。
  * 在 node 启动时，JavaScript 代码直接存储在内存中。
  * 引入过程同样经历包装。
  * 编译成功的模块缓存到 NativeModule._cache，文件模块缓存到 Module._cache。
* C/C++ 核心模块编译：
  * 纯 C/C++ 编写的部分称为内建模块。
  * 内建模块定义后，通过 NODE_Module 宏定义到 node 命名空间，node_extensions.h 头文件将散列内建模块统一放入 node_module_list 的数组中。
  * Node 使用 get_builtin_module() 方法取出。
  * 文件模块可能依赖核心模块，核心模块可能依赖内建模块。
* 核心模块引入：经历 C/C++ 层面的内建模块定义，核心模块定义以及文件模块层面引入。

## 编写核心模块

略

## C/C++ 扩展模块

略

## 模块调用栈

* C/C++ 内建模块：提供 API 给 JavaScript 核心模块和第三方 JavaScript 文件模块调用。
* JavaScript 核心模块：作为 C/C++ 内建模块的封装层和桥接层或纯功能模块。

## 包与 NPM

前略

* 问题：
  * 具备良好的测试。
  * 具备良好的文档。
  * 具备良好的测试覆盖率。
  * 具备良好的编码规范。
  * 更多条件。

## 前后端公用模块

UMD

# 第三章 异步 I/O

* 异步可消除 UI 阻塞。
* 前端体验取决于后端款速响应资源。

## 资源分配

* 多线程：
  * 缺点：创建线程和执行期线程上下文切换开销较大。复杂业务面临锁、状态同步等问题。
  * 优势：多核 CPU 上能够有效提高利用率。
* 单线程：
  * 缺点：串行执行，通常 I/O 进行会让后续任务等待。
* Node：将大规模异步 I/O 应用在应用层。

## 异步 I/O 实现现状

[同步非阻塞、异步阻塞](https://www.zhihu.com/question/39565359/answer/81999324)

* 阻塞：不向下执行。
* 异步：不直接返回结果（可能有未处理完的结果）。

现存轮询技术：
  * read：遍历查询重复检查 I/O 状态。
  * select：遍历查询通过对文件描述符的事件状态，1024 长度的数组来存储状态。
  * poll：改用链表。
  * epoll：事件通知、执行回调。非遍历查询。

非阻塞I/O
  * 理想：无须通过遍历或者事件唤醒等方式轮询，直接处理下一个任务，I/O 完成后通过信号或回调将数据传递给应用程序。
  * 现实：依靠线程池实现。

## Node 的异步 I/O

[执行过程](https://tobethelight.github.io/2018/03/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8Cnode%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/)

## 事件驱动与高性能服务器

* 同步式
* 每进程/每请求
* 每线程/每请求
* 事件驱动

# 第四章 异步编程

## 函数式编程

* 高阶函数：将函数作为参数，或将函数作为返回值的函数。
* 偏函数用法：创造一个调用另外一个部分（参数或变量已经预置的函数）的函数的用法。

## 异步编程的优势和难点

* 优势：
  * 资源更好的利用
  * 并行 -> 分布式和云
* 难点：
  * 异常处理：不能直接在同步部分捕捉异步 callback 中的错误。
  * 回调地狱：现在可以使用 promise 或 async 等解决。
  * 阻塞代码：如其他语言中的 sleep（不是死循环）。
  * 多线程编程：Node 端使用 child_process 和 cluster。
  * 异步转同步：可以使用 async。

## 异步编程解决方案

* 事件发布/订阅模式：
  * 事件超过 10 个侦听器，会警告。
  * 完整监听和捕捉 error。
  * 善用 once 绑定侦听解决雪崩问题。
* Promise/Deferred 模式：三种 Promise/Deferred 模型，Promises/A、Promises/B、Promises/D。
  * Promises/A：
    * 三种状态：未完成态、完成态、失败态。
    * 只能从未完成态向其他态转化。
    * 状态一旦转化将不能被更改。
    * 操作完成或出现错误时，将会调用对应方法。
    * then() 方法继续返回 Promise 对象。
    * Deferred 主要用于内部，维护异步模型的状态。Promise 用于外部，通过 then() 方法暴露给外部添加自定义逻辑。
    * 低级接口可以构成更多更复杂的场景，高级接口对于解决典型为题非常有效但是不如低级灵活。
  * Promise 中的多异步协作：
    * promise.all([p1, p2]).then([r1, r2, r3])
  * Promise 的进阶知识（一种实现）：
    * 队列中存储所有的回调。
    * Promise 完成时，逐个执行，当返回了新的 Promise 对象时，将当前 Deferred 对象的 promise 引用改变为新的 promise 对象（即实现 then 的链式调用）。
* 流程库控制：
  * 尾触发与 Next：同样使用队列存储中间件，使用 next 完成递归调用。
  * 其他库：现在可以使用 promise / async / await 等解决。

## 异步并发控制

* 使用队列长度完成并发控制。

# 第五章 内存控制

## V8 的垃圾回收机制与内存控制

* 内存限制：
  * Node 是基于 chrome 的 JavaScript 引擎 V8的。
  * V8 不同于其他的后端开发语言的运行环境，在内存使用上是有限制的（64 位约 1.4 GB，32 位约 0.7 GB）。无法操作大内存，如大文件一次读入内存。
* 对象分配：
  * V8 中，所有的 JavaScript 对象都是通过堆进行分配的。`process.memoryUsage()`可查看当前内存使用情况。
  * 内存使用限制是由垃圾回收机制引起，要回收内存过大时，反应时间较长，卡死其他任务，不可接受。
  * 可在启动 Node 时穿肚 `--max-old-space-size`、`--max-new-space-size` 调整内存限制大小。
* V8 的垃圾回收机制：
  * 基于分代式垃圾回收机制，即现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，再针对不同分代的内存施以更高效的算法。
  * V8 的内存分代：
    * 新生代中为存活时间较短的对象，老生代中的对象为存活时间较长或者常驻内存的对象。
    * V8 堆的整体大小就是新生代所用内存加上老生代的内存大小。
    * 源代码中，老生代（max_old_generation_size_）设置为 64 位系统下为 1400MB，32 位为 700MB；新生代（2 个 `reserved_semispace_size`）共为 32MB 和 16MB；V8 堆内存的最大保留空间为 `4 * reserved_semispace_size + max_old_generation_size_`，即为 1464MB 和 732MB.
  * Scavenge 算法
    * 使用在新生代中的算法，主要使用 Cheney 算法实现。
    * 翻转：新生代堆内存一分为二，分为 From 空间（使用中）和 To 空间（闲置），进行垃圾回收时，检查 From 空间中的存活对象，复制到 To 空间，并释放非存活对象占用，后对换 From 和 To。分代式垃圾回收的前提下，存活周期长的对象会移动到老生代完成对象晋升。
    * 晋升：两个主要条件，经历过 Scavenge 回收，To 空间的内存占比超过限制。
  * Mark-Sweep & Mark-Compact
    * 老生代中使用的方式，老生代存活对象较多且声明周期较长，使用 Scavenge 不合适。
    * Mark-Sweep 标记清除。先标记阶段遍历标记堆中活着的对象。清除阶段清除没有被标记的对象。
    * 清除后内存空间出现不连续状态。对大内存的分配是不合适的。这时出现了 Mark-Compact 标记整理。将活着的对象移动到一端，然后清理掉边界外的内存。
  * Incremental Marking（增量标记）
    * 为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种算法都要将应用全部停下来。
    * 新生代配置较小，且存活对象较少，可以容忍全停顿。
    * 使用增量标记法拆分为多“步进”，与 JavaScript 应用逻辑交替进行，直至标记阶段完成。
  * Lazy Sweeping、Incremental Compaction 等。